---
title: Structuring a repo
description: Start by creating a repository using the conventions of the ecosystem.
---

import {Callout} from '#/components/Callout'
import {PackageManagerTabs, Tab, Tabs} from '#/components/Tabs'
import {Step, Steps} from 'fumadocs-ui/components/steps'
import { File, Folder, Files } from 'fumadocs-ui/components/files';

`turbo` is built on top of Workspaces, a feature of the major package managers in the JavaScript ecosystem. This is important because it allows you to:

- Use the conventions of the JavaScript and Node.js ecosystem when starting a new repository
- Quickly, incrementally adopt Turborepo into an existing repository

In this guide, we'll walk through setting up a multi-package workspace (monorepo) so we can set the groundwork for `turbo`.

<Callout type="info">
Setting up a workspace's structure can be tedious to do by hand. If you're new to monorepos, we recommend [using `create-turbo` to get started](/repo/docs/getting-started/quickstart) with a valid workspace structure right away. From there, you can review the repository for the important files and directories we will mention in this guide.
</Callout>

## Anatomy of a workspace

In JavaScript, a workspace can either be a single package or a collection of packages. In these guides, we'll be focusing on a multi-package workspace, often called a "monorepo" (we prefer [a more specific definition](https://vercel.com/docs/vercel-platform/glossary#monorepo)).

Below are the structural keys of `create-turbo` that make it a valid workspace with Turborepo on top.

<PackageManagerTabs>
<Tab>
<Files>
  <File name="package.json" className="text-green-400" />
  <File name="package-lock.json" className="text-green-400" />
  <File name="turbo.json" className="text-green-400" />
  <Folder name="apps" defaultOpen>
    <Folder name="docs" className="text-foreground" defaultOpen>
     <File name="package.json" className="text-green-400" />
    </Folder>
    <Folder name="web">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
  <Folder name="packages">
    <Folder name="ui">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
</Files>
</Tab>

<Tab>
<Files>
  <File name="package.json" className="text-green-400" />
  <File name="yarn.lock" className="text-green-400" />
  <File name="turbo.json" className="text-green-400" />
  <Folder name="apps" defaultOpen>
    <Folder name="docs" className="text-foreground" defaultOpen>
     <File name="package.json" className="text-green-400" />
    </Folder>
    <Folder name="web">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
  <Folder name="packages">
    <Folder name="ui">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
</Files>
</Tab>

<Tab>
<Files>
  <File name="package.json" className="text-green-400" />
  <File name="pnpm-lock.yaml" className="text-green-400" />
  <File name="turbo.json" className="text-green-400" />
  <Folder name="apps" defaultOpen>
    <Folder name="docs" className="text-foreground" defaultOpen>
     <File name="package.json" className="text-green-400" />
    </Folder>
    <Folder name="web">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
  <Folder name="packages">
    <Folder name="ui">
      <File name="package.json" className="text-green-400" />
    </Folder>
  </Folder>
</Files>
</Tab>
</PackageManagerTabs>

### Minimum requirements

- [Packages as described by your package manager](#establishing-packages-in-your-monorepo)
- [A package manager lockfile](#using-a-lockfile)
- [Root `package.json`](#root-packagejson)
- [Root `turbo.json`](#root-turbojson)
- [`package.json` in each package](#packagejson-in-each-package)

### Establishing packages in your monorepo

<Steps>
<Step>
#### Specifying directories for packages

First, your package manager needs to describe the locations of your packages.

<PackageManagerTabs>
  <Tab>
  ```json title="./package.json"
  {
    "workspaces": [
      "apps/*"
      "packages/*"
    ]
  }
  ```

  <small>[→ npm workspace documentation](https://docs.npmjs.com/cli/v7/using-npm/workspaces#defining-workspaces)</small>
  </Tab>
  <Tab >
  ```json title="./package.json"
  {
    "workspaces": [
      "apps/*"
      "packages/*"
    ]
  }
  ```

  <small>[→ yarn workspace documentation](https://yarnpkg.com/features/workspaces#how-are-workspaces-declared)</small>
   </Tab>
  <Tab>
  ```json title="pnpm-workspace.yml"
 packages:
    - "apps/*"
    - "packages/*"
  ```
  <small>[→ pnpm workspace documentation](https://pnpm.io/pnpm-workspace_yaml)</small>

  </Tab>
</PackageManagerTabs>

Using this configuration, every directory **with a `package.json`** in the `apps` or `packages` directories will be considered a package.

<Callout type="error">
Turborepo does not support deeply nested workspaces like `apps/**` or `packages/**`.
</Callout>
</Step>

<Step>
#### `package.json` in each package

In the directory of the package, there must be a `package.json` to make the package discoverable to your package manager and `turbo`. The [requirements for the `package.json` of a package](#anatomy-of-a-package) are below.

</Step>
</Steps>

### Root package.json

The root `package.json` is the hub for your workspace. Below is a common example of what you would find in a root `package.json`:

```json title="./package.json"
{
  "private": true,
  "scripts": {
    "build": "turbo run build",
    "dev": "turbo run dev",
    "lint": "turbo run lint",
  },
  "devDependencies": {
    "turbo": "latest"
  },
  "packageManager": "pnpm@8.0.0"
}
```

### Root turbo.json

`turbo.json` is used to configure the behavior of `turbo`. To learn more about how to configure your pipelines and tasks, visit the [Configuring pipelines](/repo/docs/crafting-your-repository/configuring-pipelines) page.

## Using a lockfile

A lockfile must be present for `turbo` to fully understand your repository. You already should have a lockfile commited to source control already for reasons outside of `turbo` so this shouldn't be a problem.

<Callout type="warn">
If you do not have a lockfile present when you run `turbo`, you may see unpredictable behavior.
</Callout>

## Anatomy of a package

It's often best to starting thinking about designing a package as its own, unit within the workspace. At a high-level, each package is almost like it's own project, with its own `package.json`, tooling configuration, and source code. There are limits to this idea - but its a good mental model to _start_ from.

Additionally, it has specific entrypoints that other packages in your workspace can use to access the package, specified by [`exports`](#exports).

### `package.json` for a package

#### `name`

[The `name` field](https://nodejs.org/api/packages.html#name) is used to identify the package. It should be unique within your workspace.

<Callout type="info">
It's best practice to use a namespace prefix for your Internal Packages to avoid conflicts with other packages on the npm registry. For example, if your organization is named `acme`, you might name your packages `@acme/package-name`.

We use `@repo` in our docs and examples. You can choose to keep it or use your own prefix.

</Callout>
  #### `scripts`

The `scripts` field is used to define scripts that can be run from the command line in the package. We'll talk more about these scripts when it comes time to discuss [Running Tasks](/repo/docs/crafting-your-repository/running-tasks).

#### `exports`

[The `exports` field](https://nodejs.org/api/packages.html#exports) is used to specify the entrypoints for other packages that want to use the package. When you want to use code from one package in another package, you'll import from that entrypoint.

For example, if you had a `@repo/math` package, you might have the following `exports` field:

```json title="./packages/math/package.json"
{
  "exports": {
    ".": "./src/constants.ts",
    "./add": "./src/add.ts",
    "./subtract": "./src/subtract.ts"
  }
}
```

<Callout type="info">
The `exports` field in this example requires modern versions of Node.js and TypeScript.
</Callout>

This would allow you to import `add` and `subtract` functions from the `@repo/math` package like so:

```ts title="./apps/my-app/src/index.ts"
  import { GRAVITATIONAL_CONSTANT, SPEED_OF_LIGHT } from '@repo/math'
  import { add } from '@repo/math/add'
  import { subtract } from '@repo/math/subtract'
```

Using exports this way provides two major benefits:

- **Avoiding barrel files**: Barrel files are files that re-export other files in the same package, creating one entrypoint for the entire package. While they might appear convenient at a glance, they're extremely difficult for compilers and bundlers to understand and can quickly lead to performance problems. `exports` also has other powerful features compared to [the `main` field](https://nodejs.org/api/packages.html#main).
- **IDE autocompletion**: By specifying the entrypoints for your package using `exports`, you can ensure that your code editor can provide auto-completion for the package's exports.

<Callout type="good-to-know">
You may also specify `exports` using a wildcard. However, you will lose IDE autocompletion due to performance tradeoffs with the TypeScript compiler.

```json title="./packages/math/package.json"
{
  "exports": {
    "./*": "./src/*.ts"
  }
}
```

</Callout>

#### `imports` (optional)

[The `imports` field](https://nodejs.org/api/packages.html#imports) gives you a way to create subpaths to other modules within your package. You can think of these like "shortcuts" to get to other modules within your package.

<Tabs items={["package.json", "add.ts", "multiply.ts"]}>
<Tab value="package.json">
```json title="./packages/ui/package.json"
{
  "imports": {
    "#*": "./*"
  }
}
```
</Tab>
<Tab value="add.ts">
```ts title="./packages/math/src/add.ts"
 export const add = (a: number, b: number) => a + b;
```
</Tab>

<Tab value="multiply.ts">
```ts title="./packages/math/src/add.ts"
import { add } from "#add";

export const multiply = (a: number, b: number) => {
    let result = 0;
    for (let i = 0; i < b; i++) {
        result = add(result, a);
    }
    return result;
}
```
</Tab>
</Tabs>

This can be useful for concisely importing other modules within the package and can make refactors easier to manage.

<Callout type="info">
You may be more familiar with TypeScript's `compilerOptions#paths` option, which accomplishes a similar goal. As of Typescript 5.4, TypeScript can infer subpaths from `imports`, making it a better option since you'll be working with Node.js conventions. For more information, visit [our Typescript guide](/repo/docs/guides/linting/typescript).

</Callout>

### Source code

Of course, you'll want some source code in your package. Packages commonly use an `src` directory to store their source code and compile to a `dist` directory (that should also be located within the package), although this is not a requirement.

## Common pitfalls

- If you're using TypeScript, you likely don't need a `tsconfig.json` in the root of your workspace. Packages should independently specify their own TypeScript configuration, usually building off of a shared `tsconfig.json` from a separate package in the workspace. For more information, visit our [TypeScript guide](/repo/docs/guides/linting/typescript).
- You want to avoid pathing across package boundaries as much as possible. If you ever find yourself writing `../` to get from one package to another, you likely have an opportunity to re-think your approach.

## Next steps

Now that you have a workspace set up, you can use your package manager to install dependencies into your packages.
