---
title: Creating an Internal Package
description: Learn how to create an Internal Package for your monorepo.
---

import {Callout} from '#/components/Callout'
import {Steps, Step} from 'fumadocs-ui/components/steps'
import {PackageManagerTabs, Tabs, Tab} from '#/components/Tabs'
import {Files, File, Folder} from 'fumadocs-ui/components/files';

Internal Packages are the building blocks of your workspace, giving you a powerful way to share code and functionality across your repo. They also create a dependency graph for Turborepo to understand your workspace so it can follow the relationships between the packages in your repository.

TODO [IMAGERY]: Definitely a nice little dependency graph image goes here.

Let's create your first Internal Package for sharing math utilities in your repo using the guidance in the [Anatomy of a package](/repo/docs/crafting-your-repository/structuring-a-repo#anatomy-of-a-package) section. In the steps below, we assume you've [created a new repository using `create-turbo`](/repo/docs/getting-started/quickstart) or are using a similarly structured repository.

<Callout type="good-to-know">
These steps include details specific to TypeScript. If you're using JavaScript, you can ignore the TypeScript-specific information.
</Callout>

<Steps>
<Step>
### Create an empty directory

You'll need a directory to build the package in so let's create one at `./packages/math`.

<Files>
<File name="package.json" />
<File name="turbo.json" />
<Folder name="apps" />
<Folder name="packages" defaultOpen>
  <Folder name="math" className="text-green-400" defaultOpen />
  <Folder name="ui">
    <File name="package.json" />
  </Folder>
  <Folder name="eslint-config">
    <File name="package.json" />
  </Folder>
  <Folder name="typescript-config">
    <File name="package.json" />
  </Folder>
</Folder>
</Files>

</Step>
<Step>
  ### Add a `tsconfig.json`

Let's specify the TypeScript configuration for this package by adding a `tsconfig.json` file to the root of the package. TypeScript has [an `extends` key](https://www.typescriptlang.org/tsconfig#extends), allowing you to use a base configuration throughout your repository and overwrite with different options as needed.

```json title="./packages/math/tsconfig.json"
{
  "extends": "@repo/typescript-config/base.json",
  "compilerOptions": {
    "outDir": "dist"
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

You've done three important things here:

- The `@repo/typescript-config/base.json` configuration that lives in `./packages/typescript-config` has all the configuration you need so you can extend from it.
- The `outDir` key in `compilerOptions` tells TypeScript where to put the compiled output. We'll be using this directory in the next step.
- The `include` and `exclude` are not inherited from the base configuration, according to the TypeScript specification, so you've included them here.

<Callout type="info">
There's a lot more to learn about TypeScript configuration, but this is a good place to start for now. If you'd like to learn more, visit [the official TypeScript documentation](https://www.typescriptlang.org/tsconfig) or [our TypeScript guide](/repo/docs/guides/linting/typescript).
</Callout>

</Step>
<Step>
### Add a package.json

Next, we'll create the `package.json` for the package. By adding this file, you'll fulfill the two requirements for an Internal Package making it discoverable to Turborepo and the rest of your Workspace:

<PackageManagerTabs>
<Tab>
```json title="./packages/math/package.json"
{
  "name": "@repo/math",
  "scripts": {
    "dev": "tsc --watch",
    "build": "tsc"
  },
  "exports": {
    "./add": {
      "types": "./src/add.ts",
      "default": "./dist/add.js"
    },
    "./subtract": {
      "types": "./src/subtract.ts",
      "default": "./dist/subtract.js"
    }
  },
  "devDependencies": {
    "@repo/typescript-config": "*",
    "typescript": "latest"
  }
}
````

</Tab>
<Tab>
```json title="./packages/math/package.json"
{
  "name": "@repo/math",
  "scripts": {
    "dev": "tsc --watch",
    "build": "tsc"
  },
  "exports": {
    "./add": {
      "types": "./src/add.ts",
      "default": "./dist/add.js"
    },
    "./subtract": {
      "types": "./src/subtract.ts",
      "default": "./dist/subtract.js"
    }
  },
  "devDependencies": {
    "@repo/typescript-config": "workspace:*",
    "typescript": "latest"
  }
}
```
</Tab>
<Tab>
```json title="./packages/math/package.json"
{
  "name": "@repo/math",
  "scripts": {
    "dev": "tsc --watch",
    "build": "tsc"
  },
  "exports": {
    "./add": {
      "types": "./src/add.ts",
      "default": "./dist/add.js"
    },
    "./subtract": {
      "types": "./src/subtract.ts",
      "default": "./dist/subtract.js"
    }
  },
  "devDependencies": {
    "@repo/typescript-config": "workspace:*",
    "typescript": "latest"
  }
}
```
</Tab>
</PackageManagerTabs>

Let's break down this `package.json` piece-by-piece:

- **`scripts`**: The `dev` and `build` script compile the package using [the TypeScript compiler](https://www.typescriptlang.org/docs/handbook/compiler-options.html). The `dev` script will watch for changes to source code and automatically recompile the package.
- **`devDependencies`**: Install `typescript` and `@repo/typescript-config` as `devDependencies` so you can compile the package. In a real-world package, you will likely have more `devDependencies` and `dependencies` - but we can keep it simple for now.
- **`exports`**: Defines multiple entrypoints for the package so it can be used in other packages (`import { add } from '@repo/math'`).
  - The `"types"` field tells TypeScript where to find the type definitions for the package. We recommend pointing directly to source code so that you don't have to generate declaration maps. The types shown in your editor are always up to date with your source code.
  - The `"default"` field is used to tell Node.js where to find the runtime code for the package. Once we compile our Typescript with `tsc`, the output will be in the `dist` directory.

<Callout>
If you're using Typescript, you'll need to ensure that your `tsconfig.json` is using `"module": "ESNext"` and `"moduleResolution": "Bundler"` to resolve the `exports` above.

For more information, visit [the dedicated Typescript guide](/TODO-LINK).

</Callout>

Notably, this `package.json` references an Internal Package, `@repo/typescript-config`. This relationship from Turborepo's perspective, as it creates a dependency relationship between two of your packages. `@repo/math` is now a dependent of `@repo/typescript-config`.

TODO [IMAGERY]: Dependency graph image?

</Step>
<Step>
### Add an `src` directory with source code

You can now write some code for your package. Let's create the two files that we referenced in `package.json`:

<Tabs items={["add.ts", "subtract.ts"]}>
<Tab value="add.ts">
```ts title="./packages/math/src/add.ts"
 export const add = (a: number, b: number) => a + b;
```
</Tab>
<Tab value="subtract.ts">
```ts title="./packages/math/src/subtract.ts"
 export const subtract = (a: number, b: number) => a - b;
```
</Tab>
</Tabs>

</Step>

<Step>
### Add the package to an application

You're ready to use your new package in an application. Let's add it to the `web` application.

<PackageManagerTabs>
<Tab>
```diff title="apps/web/package.json"
  "dependencies": {
+   "@repo/math": "*",
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
```
</Tab>
<Tab>
```diff title="apps/web/package.json"
  "dependencies": {
+   "@repo/math": "workspace:*",
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
```
</Tab>
<Tab>
```diff title="apps/web/package.json"
  "dependencies": {
+   "@repo/math": "workspace:*",
    "next": "latest",
    "react": "latest",
    "react-dom": "latest"
  },
```
</Tab>
</PackageManagerTabs>

<Callout type="warn">
You just changed the dependencies in your repo. Make sure to run your package manager's installation command to update your lockfile.
</Callout>

With `@repo/math` now available in the `web` application, you can use it in your code:

```tsx title="apps/web/src/app/page.tsx"
import { add } from "@repo/math/add"

function Page() {
  return <div>{add(1, 2)}</div>
}

export default Page
```

</Step>

<Step>
### Run `turbo build`

Run `turbo build` in your terminal at the root of your repository.

TODO [IMAGERY]: Terminal logs image?

The `@repo/math` package built before the `web` application built so that the runtime code in `./packages/math/dist` is available to the `web` application when it bundles.

<Callout type="info">
You can run `turbo build` again to see your `web` application rebuild in **milliseconds**. We'll discuss this at length in [the Caching guide](/TODO-LINK).
</Callout>

</Step>
</Steps>

## Best practices for Internal Packages

### One "purpose" per package

When you're creating Internal Packages, it's best to create packages that have a single "purpose". This practice has several advantages:

- **Easier to understand**: As a repository scales, developers working in the repository will more easily be able to find the code they need.
- **Faster pipelines**: Being more granular about what a package does can mean it changes less often. If the source code doesn't change as often, the package will hit cache more often.
- **Reducing dependencies per package**: Using fewer dependencies per package makes it so Turborepo can more effectively [prune the dependencies of your package graph](/TODO-LINK).

What "purpose" means depends on your repository, your scale, developer needs, and more, depending on your use case. Some examples include:

- **`@repo/ui`**: A package containing all of your shared UI components
- **`@repo/tool-specific-config`**: A package for managing configuration of a specific tool
- **`@repo/graphs`**: A domain-specific library for creating and manipulating graphical data

### Application packages do not contain shared code

When you're creating packages for your applications, it's best to avoid putting shared code in those packages. Instead, you should create a separate package for the shared code and have the application packages depend on that package.

Additionally, application packages are not meant to be installed into other packages. Instead, they should be thought of as an "endpoint" of your Package Graph.

<Callout type="info">
There are rare exceptions to this rule where it can make sense to install an Application Package into another package. We've discussed these in the [Advanced section](/TODO-LINK).
</Callout>

## Next steps

With a new Internal Package now in place, we can start configuring pipelines.
