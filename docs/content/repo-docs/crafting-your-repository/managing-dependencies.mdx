---
title: Managing dependencies
description: Learn how to manage dependencies in your monorepo's workspace.
---

import {PackageManagerTabs, Tab} from '#/components/Tabs'

- **External dependencies** come from [the npm registry](https://www.npmjs.com/), allowing you to leverage valuable code from the ecosystem to build your applications and libraries faster.
- **Internal dependencies** let you share code and functionality across your repo. We will discuss them on [the next page](/repo/docs/crafting-your-repository/creating-an-internal-package).

<PackageManagerTabs>
<Tab>
```json title="./apps/web/package.json"
{
  "dependencies": {
    "next": "latest", // External dependency
    "@repo/ui": "*" // Internal dependency
  }
}
```
</Tab>
<Tab>
```json title="./apps/web/package.json"
{
  "dependencies": {
    "next": "latest", // External dependency
    "@repo/ui": "workspace:*" // Internal dependency
  }
}
```
</Tab>
<Tab>
```json title="./apps/web/package.json"
{
  "dependencies": {
    "next": "latest", // External dependency
    "@repo/ui": "workspace:*" // Internal dependency
  }
}
```
</Tab>
</PackageManagerTabs>

## Best practices for external dependencies

### Install dependencies where they're used

When you install a dependency, you should install it in the package that uses it. This is true for both internal and external dependencies. This practice has several benefits:

- **Improved clarity**: It's easier to understand what a package depends on when its dependencies are listed in its `package.json`. Developers working in the repository can see at a glance what dependencies will be available within the package.
- **Better caching ability**: If you install too many dependencies in the root of your repository, you'll be changing the workspace root whenever you add, update, or delete a dependency, leading to a lot of unnecessary cache invalidation. Instead, we can install dependencies in the package that uses them, which will only invalidate the cache for that package and the packages that depend on it.
- **Pruning unused dependencies**: For Docker users, [Turborepo's pruning feature](/TODO-LINK) can remove unused dependencies from Docker images to create lighter images. When dependencies are installed in the packages that they are meant for, Turborepo can read your lockfile and remove dependencies that aren't used in the package from your final image.

### Few dependencies in the root

Following the first principle above to [install dependencies in the package where they're used](#install-dependencies-where-theyre-used), you'll find that you naturally end up with very few dependencies in the root of your workspace.

In this mental model, dependencies in the workspace root are for repository-level management whereas dependencies for building applications and libraries are installed in packages. Some examples of dependencies that make sense to install in the root are [`turbo`](https://www.npmjs.com/package/turbo), [`husky`](https://www.npmjs.com/package/husky), or [`lint-staged`](https://www.npmjs.com/package/lint-staged).

## Managing dependencies

### Turborepo does not manage dependencies

Note that Turborepo does not play a role in managing your dependencies, leaving that work up to your package manager of choice.

It's up to the package manager to properly handle versioning, symlinking, resolving modules, and other dependency-related work. The recommendations on this page are best practices for managing dependencies in a monorepo, and are not enforced by Turborepo.

### Keeping dependencies on the same version

Some monorepo maintainers prefer to keep dependencies on the same version across all packages by rule. There are several ways to achieve this:

#### Using your package manager

You can use your package manager to update dependency versions in one command.

<PackageManagerTabs>
<Tab>
```bash title="Terminal"
npm install typescript@latest --workspaces
```
  <small>[→ npm documentation](https://docs.npmjs.com/cli/v7/using-npm/config#workspaces)</small>

</Tab>

<Tab>
Yarn 1:
```bash title="Terminal"
yarn upgrade-interactive --latest
```
<small>[→ Yarn 1 documentation](https://classic.yarnpkg.com/en/docs/cli/upgrade-interactive)</small>

Yarn 2+:

```bash title="Terminal"
yarn upgrade typescript@latest --upgrade
```

<small>[→ Yarn 2+ documentation](https://yarnpkg.com/cli/up)</small>

</Tab>

<Tab>
```bash title="Terminal"
pnpm up --recursive typescript@latest
```
  <small>[→ pnpm documentation](https://pnpm.io/cli/update#--recursive--r)</small>

</Tab>
</PackageManagerTabs>

### Using refactoring tools

Your IDE's refactoring tools can find and replace the version of a dependency across all `package.json` files in your repository at once. Try using a regex like `"next": ".*"` on `package.json` files to find all instances of the `next` package and replace them with the version you want. When you're done, make sure to run your package manager's install command to update your lockfile.

### Using purpose-built tooling

Tools like [`syncpack`](https://www.npmjs.com/package/syncpack), [`manypkg`](https://www.npmjs.com/package/@manypkg/cli), and [`sherif`](https://www.npmjs.com/package/sherif) can be used for the specific purpose of keep dependencies in lockstep.

## Next steps

Now that you know how to manage dependencies effectively in a Workspace, let's create an Internal Package to be used as a dependency in your monorepo.
