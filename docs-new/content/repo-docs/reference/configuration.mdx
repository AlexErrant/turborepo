---
title: Configuring turbo.json
description: Learn how to configure Turborepo through `turbo.json`.
---

import { Callout } from "../../../components/Callout";
import Link from "next/link";

# Configuration options (`turbo.json`)

You can configure the behavior of `turbo` by adding a `turbo.json` file in your monorepo's root directory.

Changing your root `turbo.json` file will invalidate the cache for all tasks because it's considered in [the global hash](/TODO-LINK). If you'd like the flexibility to be able to change your pipelines without impacting the hash, you can use a [Package Configuration](/TODO-LINK).

## Global options

### `extends`

`type: string[]`

The `extends` key is only valid in Workspace Configurations. It will be

### `globalDependencies`

|         |                      |
| ------- | -------------------- |
| Type    | `string[]` or `null` |
| Default | `null`               |

A list of [globs](#glob-specification-for-paths) that you want to include in all task hashes. If any file matching these globs changes, all tasks will miss cache.

These must be relative paths from the location of `turbo.json` and point to globs that are in your repository.

**Example**

```jsonc
{
  "globalDependencies": [".env", "tsconfig.json"]
}
```

In this example, if the `.env` file or `tsconfig.json` changes in any workspace, all tasks will miss cache.

### `globalEnv`

|         |                      |
| ------- | -------------------- |
| Type    | `string[]` or `null` |
| Default | `null`               |

A list of environment variables that you want to impact the hash of all tasks. Any change to these environment variables will cause all tasks to miss cache.

**Example**

```jsonc
{
  "globalEnv": ["GITHUB_TOKEN", "foo", "bar"]
}
```

In this example, if any of the `GITHUB_TOKEN`, `foo`, or `bar` environment variables change, all tasks will miss cache.

### `globalPassThroughEnv`

|         |                      |
| ------- | -------------------- |
| Type    | `string[]` or `null` |
| Default | `null`               |

A list of environment variables that you want to make available to tasks. Using this key opts all tasks into [Strict Environment Variable Mode](/TODO-LINK).

<Callout type="info">
  These values will not contribute to the hash by themselves. If you want
  changes in these variables to cause cache misses, you will need to include
  them in [`env`](#env) or [`globalEnv`](#globalenv).
</Callout>

**Example**

```jsonc
{
  "globalPassThroughEnv": ["AWS_SECRET_KEY", "GITHUB_TOKEN"]
}
```

In this example, `AWS_SECRET_KEY` and `GITHUB_TOKEN` are available to all tasks, but they will not contribute to task hashes.

### `globalDotEnv`

|         |                      |
| ------- | -------------------- |
| Type    | `string[]` or `null` |
| Default | `null`               |

A list of `.env` files whose content impacts the hash of all tasks.

Note that this does _not_ load the files into the task. Instead, it informs the _hash_ of changes in your `.env` files.

**Example**

```jsonc
{
  "globalDotEnv": [".env.local", ".env"]
}
```

In this example, any changes to your `.env.local` or `.env` files will cause all tasks to miss cache. Note that the files will not be loaded into your task. You will still need to load them into your tasks. For example, you could use [`dotenv`](https://www.npmjs.com/package/dotenv).

## Defining pipelines

### `pipeline`

Each key in the `pipeline` object is the name of a task that can be executed by [`turbo run`](/repo/docs/reference/command-line-reference/run). Turborepo will search the packages described in your [workspace's configuration](/TODO-LINK) for scripts in `package.json` with the name of the task. Using the rest of the configuration described in the pipeline, Turborepo will run the scripts in the correct order and cache outputs in [the `outputs` key](#outputs) if provided.

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"]
    },
    "test": {
      "outputs": ["coverage/**"],
      "dependsOn": ["build"],
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts"],
      "outputMode": "full"
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

## Task options

### `dependsOn`

`type: string[]`

The list of tasks this task depends on.

Prefixing an item in `dependsOn` with a `^` tells `turbo` that this pipeline task depends on the workspace's topological dependencies completing the task with the `^` prefix first (e.g. "a workspace's `build` tasks should only run once all of its `dependencies` and `devDependencies` have completed their own `build` commands").

Items in `dependsOn` without `^` prefix, express the relationships between tasks at the workspace level (e.g. "a workspace's `test` and `lint` commands depend on `build` being completed first").

<Callout type="info">
  As of version 1.5, using `$` to declare environment variables in the
  `dependsOn` config is deprecated.{" "}
  <Link href="#env">Use the `env` key instead.</Link>
</Callout>

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      // "A workspace's `build` command depends on its dependencies'
      // or devDependencies' `build` command being completed first"
      "outputs": [".next/**", "!.next/cache/**", "dist/**"],
      "dependsOn": ["^build"]
    },
    "test": {
      // "A workspace's `test` command depends on its own `lint` and
      // `build` commands first being completed"
      "dependsOn": ["lint", "build"]
    },
    "deploy": {
      // "A workspace's `deploy` command, depends on its own `build`
      // and `test` commands first being completed"
      "dependsOn": ["build", "test"]
    },
    // A workspace's `lint` command has no dependencies
    "lint": {}
  }
}
```

### `dotEnv`

`type: null | string[]`
`default: null`

The ordered list of `.env` files to include into the task's file hash. These files will be included into the hash regardless of whether or not they are included in the `git` index.

Note: this does _not_ load the files into the environment.

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dotEnv": [".env.local", ".env"]
    }
  }
}
```

### `env`

`type: string[]`

The list of environment variables a task depends on.

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "env": ["SOMETHING_ELSE"], // value will impact the hashes of all build tasks
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
    },
    "web#build": {
      "dependsOn": ["^build"],
      "env": ["STRIPE_SECRET_KEY"], // value will impact hash of only web's build task
      "outputs": [".next/**", "!.next/cache/**"]
    }
  },
  "globalEnv": [
    "GITHUB_TOKEN" // value will impact the hashes of all tasks
  ]
}
```

<Callout type="info">
  When Turborepo detects a common frontend framework in a workspace, it will
  automatically depend on environment variables that are going to be inlined in
  your build. For example, if the `web` workspace contains a Next.js project,
  you do not need to specify any environment variables that [start with
  `NEXT_PUBLIC_`](https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser)
  in the `dependsOn` config. Turborepo already knows that the build output will
  change when the value of these environment variables change, so it will depend
  on them automatically. See more in the [docs on
  caching](/repo/docs/core-concepts/caching#automatic-environment-variable-inclusion).
</Callout>

### `passThroughEnv`

`type: string[]`

This config goes inside each task definition in the [`pipeline`][r-config-pipeline].

An allowlist of environment variables that should be made available to this task
but should not contribute to the task's cache key. Using this key opts this task
into `strict` environment variable mode.

Changing this list will contribute to the task's cache key, but the value of each
variable will not.

**Example**

`AWS_SECRET_KEY` and `GITHUB_TOKEN` are available to the `build` task, but not to the `lint` task
in `strict` [env mode][r-cli-env-mode].

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "passThroughEnv": ["AWS_SECRET_KEY", "GITHUB_TOKEN"]
    },
    "lint": {}
  }
}
```

[r-config-pipeline]: #pipeline
[r-cli-env-mode]: /repo/docs/reference/command-line-reference/run#--env-mode

### `outputs`

`type: string[]`

The set of glob patterns of a task's cacheable filesystem outputs.

Note: `turbo` automatically logs `stderr`/`stdout` to `.turbo/run-<task>.log`. This file is _always_
treated as a cacheable artifact and never needs to be specified.

Omitting this key or passing an empty array can be used to tell `turbo` that a task is a side-effect
and thus doesn't emit any filesystem artifacts (e.g. like a linter), but you still want to cache its
logs (and treat them like an artifact).

<Callout type="info">
  `outputs` globs must be specified as relative paths rooted at the workspace
  directory.
</Callout>

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      // "Cache all files emitted to workspace's dist/** or .next
      // directories by a `build` task"
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"],
      "dependsOn": ["^build"]
    },
    "test": {
      // "Don't cache any artifacts of `test` tasks (aside from
      // logs)"
      "dependsOn": ["build"]
    },
    "test:ci": {
      // "Cache the coverage report of a `test:ci` command"
      "outputs": ["coverage/**"],
      "dependsOn": ["build"]
    },
    "dev": {
      // Never cache anything (including logs) emitted by a
      // `dev` task
      "cache": false,
      "persistent": true
    }
  }
}
```

### `cache`

`type: boolean`

Defaults to `true`. Whether or not to cache the task [`outputs`](#outputs). Setting `cache` to false is useful for daemon or long-running "watch" or development mode tasks you don't want to cache.

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "outputs": [".svelte-kit/**", "dist/**"],
      "dependsOn": ["^build"]
    },
    "test": {
      "dependsOn": ["build"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

### `inputs`

`type: string[]`

Tells `turbo` the set of files to consider when determining if a package has changed for a particular task.
Setting this to a list of globs will cause the task to only be run when files matching those globs have
changed. This can be helpful if you want to, for example, skip running tests unless a source file changed, or
explicitly depend on a `.gitignore`d file.

Because specifying an `inputs` key immediately opts out of the default behavior, you may specify
the special string `$TURBO_DEFAULT$` within an inputs array to include all default inputs. This is useful
if you want to add or remove additional inputs from the default set.

The default is `[]` to run the task when any file in the package changes.

<Callout type="info">
  `inputs` globs must be specified as relative paths rooted at the package's
  directory.
</Callout>

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "test": {
      // A package's `test` task should only be ran when
      // either a `.tsx` or `.ts` file has changed.
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts"]
    }
  }
}
```

`$TURBO_DEFAULT$` **Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "check-types": {
      // Consider all default inputs except the README.md
      "inputs": ["$TURBO_DEFAULT$", "!README.md"]
    }
  }
}
```

<Callout type="info">
  Note: `turbo.json` is *always* considered an input. If you modify
  `turbo.json`, all caches are invalidated.
</Callout>

### `outputMode`

`type: "full" | "hash-only" | "new-only" | "errors-only" | "none"`

Set type of output logging. Can be overriden by the [`--output-logs`](/repo/docs/reference/command-line-reference/run#--output-logs) CLI option.

| option      | description                         |
| ----------- | ----------------------------------- |
| full        | Displays all output (default)       |
| hash-only   | Show only the hashes of the tasks   |
| new-only    | Only show output from cache misses  |
| errors-only | Only show output from task failures |
| none        | Hides all task output               |

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".svelte-kit/**", "dist/**"],
      "outputMode": "new-only"
    },
    "test": {
      "dependsOn": ["build"]
    }
  }
}
```

### `persistent`

`type: boolean`

Label a task as `persistent` if it is a long-running process, such as a dev server or `--watch` mode.
Turbo will prevent other tasks from depending on persistent tasks. Without setting this
config, if any other task depends on `dev`, it will never run, because `dev` never exits. With this
option, `turbo` can warn you about an invalid configuration.

**Example**

```jsonc
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "dev": {
      "persistent": true
    }
  }
}
```

## Glob specification for paths

Turborepo's glob implementation allows you to specfically define the files you want `turbo` to interact with. The most useful patterns you'll need are in the table below:

| Pattern             | Description                                                                        |
| ------------------- | ---------------------------------------------------------------------------------- |
| `*`                 | Match all files in the directory                                                   |
| `**`                | Recursively match all files and sub-directories                                    |
| `some-dir/`         | Match the `some-dir` directory **but not its contents**                            |
| `some-dir*`         | Match files and directories that start with `some-dir`                             |
| `*.js`              | Matches all `.js` files in the directory                                           |
| `*.{js,ts,tsx,jsx}` | Matches all files that end with the provided extensions in the directory           |
| `*.{js?x}`          | Matches all files with the `js` and `jsx` extensions in the directory              |
| `!`                 | Negate the whole glob (automatically applies `/**` to the end of the defined glob) |

Here are a few examples of how to use these patterns:

| Pattern            | Description                                                                                       |
| ------------------ | ------------------------------------------------------------------------------------------------- |
| `dist/**`          | Match all files in the `dist` directory and all sub-directories                                   |
| `dist/some-dir/**` | Match all files in the `dist/some-dir` directory and all sub-directories in the current directory |
| `dist/`            | Match the `dist` directory **but not its contents**                                               |
| `dist`             | Match the `dist` directory **but not its contents**                                               |
| `!dist`            | Ignore the `dist` directory **and all of its contents**                                           |
| `dist*`            | Match files and directories that start with `dist`                                                |
| `dist/*.js`        | Match all `.js` files in the `dist` directory                                                     |
| `!dist/*.js`       | Ignore all `.js` files in the `dist` directory                                                    |
| `dist/**/*.js`     | Recursively match all `.js` files in the `dist` directory and its sub-directories                 |
| `../scripts/**`    | Up one directory, match all files and sub-directories in the `scripts` directory                  |

[1]: /repo/docs/core-concepts/monorepos/configuring-workspaces
